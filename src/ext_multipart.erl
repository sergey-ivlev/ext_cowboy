%%%-------------------------------------------------------------------
%%% @author egobrain <egobrain@linux-ympb>
%%% @copyright (C) 2012, egobrain
%%% @doc
%%%  Function for uploading files and properties,which were sent as a
%%%  multipart. Files are stored in tmp_folder with random name,
%%%  generated by tmp_filename function.
%%% @end
%%% Created : 25 Mar 2012 by egobrain <egobrain@linux-ympb>
%%%-------------------------------------------------------------------
-module(ext_multipart).

-export([
         process/1,
         process/2,
         process/3
        ]).

-record(state,{
          handler,
          handler_state
         }).

%% ===================================================================
%%% Api
%% ===================================================================

process(Req) ->
    process(Req, []).

process(Req, Opts) ->
    process(Req, ext_multipart_default_handler, Opts).

process(Req, Handler, HandlerOpts) ->
    State = #state{
        handler=Handler,
        handler_state = Handler:init(HandlerOpts)
    },
    run_fsm(fun acc/2, Req, State).

%% ===================================================================
%%% Internal functions
%% ===================================================================
acc(Req, State) ->
    case cowboy_req:part(Req) of
        {ok, Headers, Req2} ->
            F = fun(R, S) ->
                        acc_file(Headers, R, S, fun acc/2)
                end,
            {next, F, Req2, State};
        {done, Req2} ->
            {finish, Req2, State}
    end.

acc_file(Headers, Req,
    #state{
        handler = Handler,
        handler_state = HandlerState
    }=State, Succ) ->
    case Handler:start_of_part(Headers, HandlerState) of
        {ok, HandlerState2} ->
            State2 = State#state{
                handler_state=HandlerState2
            },
            F = fun(R, S) -> acc_file_data(R, S, Succ) end,
            {next, F, Req, State2};
        {error, Reason} ->
            {terminate, Reason, Req, State}
    end.

acc_file_data(Req,
    #state{
        handler = Handler,
        handler_state = HandlerState
    }=State, Succ) ->
    case cowboy_req:part_body(Req) of
        {ok, Data, Req2} ->
            case Handler:end_of_part(Data, HandlerState) of
                {ok, HandlerState2} ->
                    State2 = State#state{
                        handler_state=HandlerState2
                    },
                    {next, Succ, Req2, State2};
                {error, Reason} ->
                    {terminate, Reason, Req, State}
            end;
        {more, Data, Req2} ->
            case Handler:part_data(Data, HandlerState) of
                {ok, HandlerState2} ->
                    State2 = State#state{
                        handler_state=HandlerState2
                    },
                    F = fun(R, S) -> acc_file_data(R, S, Succ) end,
                    {next, F, Req2, State2};
                {error, Reason} ->
                    {terminate, Reason, Req, State}
            end
    end.

run_fsm(Cur, Req, State) ->
    Res = try
        Cur(Req, State)
    catch E:R ->
            terminate(R, Req, State),
            erlang:raise(E, R, erlang:get_stacktrace())
    end,
    case Res of
        {next, Next, Req2, State2} ->
            run_fsm(Next, Req2, State2);
        {terminate, Reason, Req2, State2} ->
            terminate(Reason, Req2, State2);
        {finish, Req2, State2} ->
            finish(Req2, State2)
    end.

terminate(Reason, Req, #state{handler=Handler, handler_state=HandlerState}) ->
    ok = Handler:terminate(Reason, HandlerState),
    {error, Reason, Req}.

finish(Req, #state{handler=Handler, handler_state=HandlerState}) ->
    case Handler:finish(HandlerState) of
        {ok, Proplist} ->
            Req2 = lists:foldl(
                     fun({K, V}, R) ->
                             cowboy_req:set_meta(K, V, R)
                     end, Req, Proplist),
            {ok, Req2};
        {error, Reason} ->
            {error, Reason, Req}
    end.
